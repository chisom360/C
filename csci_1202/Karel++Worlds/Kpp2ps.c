/*      Kpp2PS    Karel++ Path File to PostScript File Converter
 *                      (C) Copyright 1998 Jason Rush,
 *                      All rights reserved.
 *
 *      This program is designed to convert a path file generated by the
 *      hacked version of the Karel Simulator by Jim Polzin and Jason Rush.
 *
 *      It takes up to three file names on the command line, and produces
 *      a attractive encapsulated postscript file intended for grading
 *      purposes.
 *
 *      This software is NOT in the Public Domain!
 */

/*
 *      Exit Codes:
 *              0:  No Error, program finnished sucessfully.
 *              1:  Error with file names or command-line arguments.
 *              2:  Error closing files before exiting program.
 *              3:  Error with world file, unexpected EOF or not valid world file.
 *              4:  Error opening the specified file(s).
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <signal.h>


/* Definitions */
#define MULT 50


/* External Variables */
int max_x, max_y, min_x, min_y;                 /* For the max & min points     */
int beeperRadius = 3;
char beeperFormat[7] = "fill";
FILE *world, *path, *post;                              /* I/O files                    */


/* Prototypes */
void arrow(int x1, int y1, int x2, int y2);
void print_header(int wflg, float margin);
void min_max(int wflg, char **pth_file);
void read_wol(int wflg);
void read_pth(void);
void dofiles(char *filename, char **pth_file, char *wol_file, char *eps_file, char *basename);
void file_err(void);


int main(int argc, char *argv[])
{
    char temp[45], **pth_file, wol_file[45], eps_file[45], basename[45];
    int qflg = 0,
        wflg = 0,
        i;
    float margin = 20.0;
    time_t tp;
    struct tm *ltime;


    /* Print Title and Copyright Info */
    fprintf(stderr, "\nKarel++ Path File to PostScript Converter  v1.02\n");
    fprintf(stderr, "(C) Copyright 2000 Jason Rush & Jim Polzin,\nAll Rights Reserved\n\n");
   signal(SIGSEGV, (void*)file_err);

    if(argc == 3)
      wflg = 1;
    argc--;
    argv++;
    while((argc > 0) && (**argv == '-' || **argv == '/'))
    {   /* Process command-line switches */
      (*argv)++;
      while(**argv)
      switch (*(*argv)++)
         {
             case 'Q':   /* Quick Command-Line Mode */
             case 'q':
               qflg = 1;
               break;
             case 'W':   /* Produce World Only Mode */
         case 'w':
               wflg = 1;
               break;
            case 'M':
            case 'm':
               if (**argv == ':')
                  (*argv)++;

               if(sscanf(*argv, "%f", &margin) != 1)
          {
                  fputs("\aError: Bad margin amount!\n", stderr);
         exit(1);
          }
               if(margin < 0 || margin > 300)
          {
                  fputs("\aError: Margin must be between 0 and 300!\n", stderr);
         exit(1);
          }
               **argv = '\0';
               break;
            case 'O':
            case 'o':
                   strcpy(beeperFormat, "stroke");
                   break;
            case 'B':
            case 'b':
                   fputs("Argv: ", stderr);
                   fputs(*argv, stderr);
              if(sscanf(*argv, "%d", &beeperRadius) != 1)
               {
                  fputs("\aError: Beeper radius invalid\n", stderr);
                  exit(1);
               }
               **argv = '\0';
               break;
             case 'H':
             case 'h':
             case '?':
               fputs("Usage:\tKPP2PS -[switches] <file.wol> <file.pth> <file.eps>\n\n", stderr);
               fputs("Switches:\t-q\tQuick Command-Line Mode: Give only one of the three", stderr);
               fputs("\t\t\t\tfilenames, and let K2PS infer the other two.\n\n", stderr);
               fputs("\t\t-w\tWorld Only: Only the world will be converted, give\n", stderr);
               fputs("\t\t\tonly the world and postscript files for input.\n\n", stderr);
               fputs("\t\t-m\tSet Margins: Specify a number or fraction of points\n", stderr);
               fputs("\t\t\tto set a equal margin all the way around the picture.\n", stderr);
               fputs("\t\t\t(defaults to 20 points if the switch is not set.)\n\n", stderr);
          fputs("\t\tNote:\tThe -q and -w switches can be used in conjunction;\n", stderr);
          fputs("\t\t\thowever, a path file cannot be specified as the quick\n", stderr);
          fputs("\t\t\tfilename because path files are not needed to convert\n", stderr);
          fputs("\t\t\ta world file.\n", stderr);
               return 0;
             default:
                fputs("\aError: Unknown option.\n", stderr);
               fputs("For help, type \"KPP2PS -?\"\n", stderr);
               return 1;
         }
         argc--;
         argv++;
    }
    if(argc >= 3 && qflg == 0 && wflg == 0)
    {   /* Process Files normaly */
      pth_file = calloc(sizeof(char *),argc+1);
      while(argc != 0)
      {
      dofiles(*argv, pth_file, wol_file, eps_file, basename);
          argc--;
          argv++;
      }
      printf("Path file length: %d\n", sizeof(pth_file));
      for(i=0; pth_file[i] != NULL; i++)
        printf("Path file: %s\n", pth_file[i]);
    }
    else if(wflg == 1 && argc == 2 && qflg == 0)
    {   /* Process Files when w flag is set */
      pth_file = calloc(sizeof(char *),argc+1);
      while(argc != 0)
      {
          dofiles(*argv, pth_file, wol_file, eps_file, basename);
      argc--;
          argv++;
      }
    }
    else if(qflg == 1 && argc == 1 && wflg == 0)
    {   /* Process files if q flag is set */
      *wol_file = '\0';
      *pth_file = '\0';
      *eps_file = '\0';
      
      pth_file = calloc(sizeof(char *),argc+1);
      dofiles(*argv, pth_file, wol_file, eps_file, basename);

      if(strlen(*pth_file))
      {       /* Infer wol and eps from the pth filename */
          strcpy(temp, basename);
          strcat(temp, ".wol");
      dofiles(temp, pth_file, wol_file, eps_file, basename);
          strcpy(temp, basename);
          strcat(temp, ".eps");
      dofiles(temp, pth_file, wol_file, eps_file, basename);
      }
      else if(strlen(wol_file))
      {       /* Infer pth and eps from the wol filename */
          strcpy(temp, basename);
      strcat(temp, ".pth");
          dofiles(temp, pth_file, wol_file, eps_file, basename);
          strcpy(temp, basename);
      strcat(temp, ".eps");
          dofiles(temp, pth_file, wol_file, eps_file, basename);
      }
      else if(strlen(eps_file))
      {       /* Infer wol and pth from the eps filename */
          strcpy(temp, basename);
          strcat(temp, ".wol");
      dofiles(temp, pth_file, wol_file, eps_file, basename);
          strcpy(temp, basename);
          strcat(temp, ".pth");
      dofiles(temp, pth_file, wol_file, eps_file, basename);
      }
   }
    else if(qflg == 1 && wflg == 1 && argc == 1)
    {   /* Process files if w flag and q flag is set */
      *wol_file = '\0';
      *pth_file = '\0';
      *eps_file = '\0';
      
      pth_file = calloc(sizeof(char *),argc+1);
      dofiles(*argv, pth_file, wol_file, eps_file, basename);

      if(strlen(wol_file))
      {       /* Infer eps from the wol filename */
          strcpy(temp, basename);
      strcat(temp, ".eps");
          dofiles(temp, pth_file, wol_file, eps_file, basename);
      }
      else if(strlen(eps_file))
      {       /* Infer wol from the eps filename */
          strcpy(temp, basename);
          strcat(temp, ".wol");
      dofiles(temp, pth_file, wol_file, eps_file, basename);
      }
      else if(strlen(*pth_file))
      {       /* Print Error message if invalid filenames are given */
          fputs("\aError: Invalid filename given!\n", stderr);
         fputs("For help, type \"K2PS -?\"\n", stderr);
      return 1;
      }
    }
    else
    {   /* Print Error message if invalid number of filenames given */
   fputs("\aError: Invalid Number of filename(s)!\n", stderr);
      fputs("For help, type \"K2PS -?\"\n", stderr);
      return 1;
    }


    if(!wflg)
    {   /* Don't open the path file if only producing the world */
      if((path = fopen(*pth_file, "r")) == NULL)
      {
          fprintf(stderr, "\aError: Cannot open file: %s!\n\n", *pth_file);
      }
    }
    if((world = fopen(wol_file, "r")) == NULL)
    {
      fprintf(stderr, "\aError: Cannot open file: %s!\n\n", wol_file);
   }
    if((post = fopen(eps_file, "w")) == NULL)
    {
      fprintf(stderr, "\aError: Cannot open file: %s!\n\n", eps_file);
   }


    /* Get the max and min points */
    min_max(wflg,pth_file);

    /* Write PostScript Header and Functions */
    print_header(wflg, margin);

    /* Process the world file */
    read_wol(wflg);

    if(!wflg)
    {   /* Process the path file */
      /* Print time and name on bottom of the screen */
      tp = time(NULL);
      ltime = localtime(&tp);
      strftime(temp, 45, "%D  %I:%M:%S %p", ltime);

      read_pth();

      i=1;
      while(*(pth_file+i)){
        fclose(path);
        fprintf(post, "%s     %s) show\n", wol_file, temp);
        fprintf(stderr, "Path: %s\n", pth_file[i]);
        if((path=fopen(pth_file[i],"r"))==NULL)
          fprintf(stderr, "\aError: Cannot open file: %s!\n\n", pth_file[i]);
        else
          read_pth();
        i++;
      }

      fprintf(post, "%s     %s) show\n", wol_file, temp);
    }
    else{
      fputs("114 4 moveto\n", post);
      fprintf(post, "(%s) show\n", wol_file);
    }
/*    fputs("\nshowpage\n%%EndDocument\n%%Trailer", post);
*/
    fputs("375 4 moveto\n", post);
    fputs("(Avenues ) show\n", post);
    fputs("90 rotate\n", post);
//    fputs("375 -10 moveto\n", post);
    fputs("175 -10 moveto\n", post);
    fputs("(Streets ) show\n", post);

    fputs("\nshowpage\n%%Trailer", post);


    /* Close the files */
    if(!wflg && fclose(path) == EOF)
    {
      fprintf(stderr, "\aError: Could Not Close the File(s)\n\n");
      return 2;
    }
    if(fclose(world) == EOF || fclose(post) == EOF)
    {
      fprintf(stderr, "\aError: Could Not Close the File(s)\n\n");
      return 2;
    }

    fprintf(stderr, "%s file created successfully.\n\n", eps_file);

    return 0;
}


/* Routine to draw a PostScript arrow */
void arrow(int x1, int y1, int x2, int y2)
{
    fprintf(post, "%d %d %d %d 1 4 4 arrow\n", x1, y1, x2, y2);
}


/* Routine to produce the PostScript header */
void print_header(int wflg, float margin)
{
    float scale;
    int flag = 0;

    fprintf(stderr, "Lower Left Corner:\n\tstreet: %d\n\tavenue: %d\n\n", min_y, min_x);
    fprintf(stderr, "Upper Right Corner:\n\tstreet: %d\n\tavenue: %d\n\n", max_y, max_x);

//////////////// page_width = 612     page_height = 792 /////////////////////
    if(  ( (612.0-(2*margin))/((max_x*MULT)+25) ) < ( (792.0-(2*margin))/((max_y*MULT)+25) )  )
    {   /* Determine if file should be scaled by height or width */
      scale = (612.0-(2*margin))/((max_x*MULT)+25);
      flag = 1;
    }
    else
      scale = (792.0-(2*margin))/((max_y*MULT)+25);

    fprintf(stderr, "Margin set to: %.2f pt.\n", margin);
    fprintf(stderr, "Picture scaled by %.2f%% to fit the paper size.\n\n", scale * 100);

    if(flag)    /* Print Bounding Box if scaled by width */
   fprintf(post, "%%!PS-Adobe-3.0 EPSF-3.0\n%%%%BoundingBox: %.2f %.2f %.2f %f\n%%%%EndComments\n\n", margin, margin, 612-margin, (((max_y*MULT)+25)*scale)+margin );
    else                /* Print Bounding Box if scaled by height */
      fprintf(post, "%%!PS-Adobe-3.0 EPSF-3.0\n%%%%BoundingBox: %.2f %.2f %f %.2f \n%%%%EndComments\n\n", margin, margin, (((max_x*MULT)+25)*scale)+margin, 792-margin);

    fputs("/beepertxt /Times-Roman findfont 10 scalefont def\n/normtxt /Times-Roman findfont 10 scalefont def\n\n\n", post);
    fputs("%%%%%%%%%%  DICTIONARY  %%%%%%%%%%\n", post);

    if(!wflg)   /* PostScript dictionary specific to path files */
      fputs("/arrowdict 14 dict def\narrowdict begin\n        /mtrx matrix def\nend\n\n", post);

    fputs("/beeperdict 4 dict def\n\n/linedict 4 dict def\n\n/griddict 3 dict def\n\n", post);
    fputs("/headdict 4 dict def\nheaddict begin\n        /mtrx matrix def\nend\n\n\n", post);


    fputs("%%%%%%%%%%   ROUTINES   %%%%%%%%%%\n", post);

    if(!wflg)
    {   /* PostScript routines specific to path files */
      fputs("/arrow\n{ arrowdict begin\n        /headlength exch def\n        /halfheadthickness exch 2 div def\n        /halfthickness exch 2 div def\n", post);
      fputs("        /tipy exch def /tipx exch def\n        /taily exch def /tailx exch def\n\n        /dx tipx tailx sub def\n        /dy tipy taily sub def\n", post);
      fputs("        /arrowlength dx dx mul dy dy mul add sqrt def\n        /angle dy dx atan def\n        /base arrowlength headlength sub def\n\n", post);
      fputs("        /savematrix matrix currentmatrix def\n\n        tailx taily translate\n        angle rotate\n\n        newpath\n           0 halfthickness neg moveto\n", post);
      fputs("           base halfthickness neg lineto\n           base halfheadthickness neg lineto\n           arrowlength 0 lineto\n           base halfheadthickness lineto\n", post);
      fputs("           base halfthickness lineto\n           0 halfthickness lineto\n           closepath\n        fill\n        savematrix setmatrix\n  end\n} def\n\n", post);

      fputs("/putbeeper\n{ beeperdict begin\n        /beepers exch def\n        /y exch def\n        /x exch def\n\n        newpath\n", post);
//      fprintf(post,"           x y %d 0 360 arc\n           0 setlinewidth\n        fill\n        x 5 add y 5 add moveto\n        beepertxt setfont\n", beeperRadius);
      fprintf(post,"           x y %d 0 360 arc\n           1 setlinewidth\n         %s\n       x 5 add y 5 add moveto\n        beepertxt setfont\n", 
                   beeperRadius, beeperFormat);
      fputs("        beepers show\n  end\n} def\n\n", post);

      fprintf(post,"/pickbeeper\n{ beeperdict begin\n        /beepers exch def\n        /y exch def\n        /x exch def\n\n        newpath\n           x y %d 0 360 arc\n", beeperRadius);
      fputs("           0 setlinewidth\n        stroke\n        x 5 add y 5 add moveto\n        beepertxt setfont\n        beepers show\n  end\n} def\n\n", post);

      fputs("/pick&put\n{ beeperdict begin\n        /beepers exch def\n        /y exch def\n        /x exch def\n\n        0 setlinewidth\n        newpath\n", post);
      fprintf(post,"           x y %d 0 360 arc\n        stroke\n        newpath\n           x y 3 45 225 arc\n        fill\n\n        x 5 add y 5 add moveto\n        beepertxt setfont\n", beeperRadius);
      fputs("        beepers show\n  end\n} def\n\n", post);
   }

    fputs("/line\n{ linedict begin\n        /y2 exch def\n        /x2 exch def\n        /y1 exch def\n        /x1 exch def\n\n        newpath\n           x1 y1 moveto\n", post);
    fputs("           x2 y2 lineto\n           5 setlinewidth\n        stroke\n  end\n} def\n\n", post);

    fputs("/gridx\n{ griddict begin\n        /x1 exch def\n        /y1 exch def\n\n", post);
    fprintf(post, "        /x2 x1 %d add def\n\n", (max_x - 1) * MULT + 25);
    fputs("        normtxt setfont\n", post);
    fputs("        /str 20 string def\n", post);
    fputs("        x1 12 sub y1 moveto\n", post);
    fputs("        y1 50 idiv str cvs show\n", post);

    
    fputs("        newpath\n           x1 y1 moveto\n", post);
    fputs("           x2 y1 lineto\n           0 setlinewidth\n        stroke\n  end\n} def\n\n", post);

    fputs("/gridy\n{ griddict begin\n        /y1 exch def\n        /x1 exch def\n\n", post);
    fprintf(post, "        /y2 y1 %d add def\n\n", (max_y - 1) * MULT + 25);
    fputs("        normtxt setfont\n", post);
    fputs("        /str 20 string def\n", post);
    fputs("        x1 y1 12 sub moveto\n", post);
    fputs("        x1 50 idiv str cvs show\n", post);
    fputs("        newpath\n           x1 y1 moveto\n", post);
    fputs("           x1 y2 lineto\n           0 setlinewidth\n        stroke\n  end\n} def\n\n", post);

    fputs("/head\n{ headdict begin\n        /angle exch def\n        /y exch def\n        /x exch def\n\n        /savematrix matrix currentmatrix def\n", post);
    fputs("        x y translate\n        angle rotate\n\n        newpath\n           4.75 0 moveto\n           -4 4.25 lineto\n", post);
    fputs("           -4 -4.25 lineto\n           4.75 0 lineto\n           closepath\n         fill\n\n        savematrix setmatrix\n  end\n} def\n\n", post);

   fputs("/wolbeep\n{ beeperdict begin\n        /beepers exch def\n        /y exch def\n        /x exch def\n\n        newpath\n", post);
//   fputs("           x y 1.5 0 360 arc\n           0 setlinewidth\n        fill\n        x 5 add y 12 sub moveto\n        beepertxt setfont\n", post);
   fprintf(post,"           x y %d 0 360 arc\n           0 setlinewidth\n        %s\n        x 5 add y 12 sub moveto\n        beepertxt setfont\n", 
           beeperRadius, beeperFormat);
   fputs("        beepers show\n  end\n} def\n\n\n", post);

    fprintf(post, "%.2f %.2f translate\n", margin, margin);
    fprintf(post, "%f %f scale\n\n", scale, scale);
}


/* Get the max and min points */
void min_max(int wflg, char**pth_file)
{
    int x, y, beepers;
    char temp[7];


    /* Check for the "ROCHES" header */
    if(fscanf(world, "%6s", temp) != 1)
    {   /* Print error message is string was not returned */
      fputs("\aError: Not a valid world file!\n", stderr);
      exit(3);
    }
    if(strcmp(temp, "ROCHES"))
    {   /* Print error message if string doesn't match "ROCHES" */
      fputs("\aError: Not a valid world file!\n", stderr);
      exit(3);
    }

    /* Read world file for min & max */
    if(fscanf(world, "%*d %*d %d %d %*d %*d", &y, &x) == 2)
    {                           /* read first line and set initial values */
      max_y = min_y = y;
      max_x = min_x = x;
      while(fscanf(world, "%d %d %d %*d %*d %*d %*d", &y, &x, &beepers) == 3)
      {       /* read rest of file and figure out min & max */
      /* wall, not beeper */
          if(beepers == 0 && x > max_x)
            max_x = x+1;
      if(beepers == 0 && x < min_x)
            min_x = x;

          if(beepers == 0 && y > max_y)
            max_y = y+1;
          if(beepers == 0 && y < min_y)
            min_y = y;

          /* Beeper on corner */
          if(beepers > 0 && x + 1 > max_x)
            max_x = x + 1;
          if(beepers > 0 && x - 1 < min_x)
            min_x = x - 1;

          if(beepers > 0 && y + 1 > max_y)
            max_y = y + 1;
      if(beepers > 0 && y - 1 < min_y)
            min_y = y - 1;
      }
    }

    if(!wflg)
    {   /* Read path file for min/max */
      int i;
      fclose(path);
      
      for(i=0;(*(pth_file+i));i++){
        if((path=fopen(pth_file[i],"r"))==NULL)
          fprintf(stderr, "\aError: Cannot open file: %s!\n\n", pth_file[i]);
        else{
          while(fscanf(path, "%d %d %*d %*d", &y, &x) == 2)
          {
            if(x + 1 > max_x)
              max_x = x+1;
            if(x - 1 < min_x)
              min_x = x-1;

            if(y + 1 > max_y)
              max_y = y+1;
            if(y - 1 < min_y)
              min_y = y-1;
          }
          fclose(path);
        }
      }
      if((path=fopen(pth_file[0],"r"))==NULL)
          fprintf(stderr, "\aError: Cannot open file: %s!\n\n", pth_file[i]);
    }

    rewind(world);
}



/* Read world file */
void read_wol(int wflg)
{
    int x1, y1, x2, y2, direction, beepers, n, s, e, w;
    char temp[7];

    /* Check for the "ROCHES" header */
    if(fscanf(world, "%6s", temp) != 1)
    {   /* Print error message if no string was returned */
      fputs("\aError: Not a valid world file!\n", stderr);
      exit(3);
   }
    if(strcmp(temp, "ROCHES"))
    {   /* Print error message if string doesn't match "ROCHES" */
      fputs("\aError: Not a valid world file!\n", stderr);
      exit(3);
    }

    fputs("%%%%%%%%%%  WORLD FILE  %%%%%%%%%%\n", post);
    fprintf(post, "50 50 %d {25 gridx} for\n50 50 %d {25 gridy} for\n", (max_y - 1) * MULT + 50, (max_x - 1) * MULT + 50);
    fprintf(post, "23 25 %d 25 line\n25 23 25 %d line\n", (max_x - 1) * MULT + 50, (max_y - 1) * MULT + 50);
    if(fscanf(world, "%d %d %d %d %d %*d", &y2, &x2, &y1, &x1, &direction) != 5)
    {   /* Read first line  (lower corner x, y, Karels initial x, y, Direction, Beepers in bag) */
      fputs("\aError: Unexpected end of file!\n", stderr);
      exit(4);
    }

#ifdef UNDEF
    /* Place Karel in his inital position */
    if(wflg){
    if(direction == 1)            /* Face Karel North */
      fprintf(post, "%d %d 90 head\n", x1 * MULT, y1 * MULT);
    else if(direction == 2)       /* Face Karel South */
      fprintf(post, "%d %d 270 head\n", x1 * MULT, y1 * MULT);
    else if(direction == 3)       /* Face Karel East */
      fprintf(post, "%d %d 0 head\n", x1 * MULT, y1 * MULT);
    else if(direction == 4)       /* Face Karel West */
      fprintf(post, "%d %d 180 head\n", x1 * MULT, y1 * MULT);
    }
#endif
    while(fscanf(world, "%d %d %d %d %d %d %d", &y1, &x1, &beepers, &n, &s, &e, &w) == 7)
    {   /* Read rest of file & produce world */
   /* place walls to N, S, E, or W */
      if(n)
          fprintf(post, "%d %d %d %d line\n",
               (x1 * MULT) - 27, (y1 * MULT) + 25, (x1 * MULT) + 27, (y1 * MULT) + 25);
      if(s)
          fprintf(post, "%d %d %d %d line\n",
                (x1 * MULT) - 27, (y1 * MULT) - 25, (x1 * MULT) + 27, (y1 * MULT) - 25);
      if(e)
          fprintf(post, "%d %d %d %d line\n",
                (x1 * MULT) + 25, (y1 * MULT) - 27, (x1 * MULT) + 25, (y1 * MULT) + 27);
      if(w)
          fprintf(post, "%d %d %d %d line\n",
                (x1 * MULT) - 25, (y1 * MULT) - 27, (x1 * MULT) - 25, (y1 * MULT) + 27);

   /* Place numbers of beepers originally in world */
      if(beepers > 0)
      fprintf(post, "%d %d (%d) wolbeep\n", (x1 * MULT), (y1 * MULT), beepers);
    }
    rewind(world);
}


/* Process the path file */
void read_pth(void)
{
    long int pos;
    static int error_pos = 6;
    int x1, x2, y1, y2, flag1, flag2, direction, beepers2;


    fseek(path, (long int) 0, SEEK_END);
    pos = ftell(path);
    pos -= 7;
    fseek(path, (long int) 0, SEEK_SET);

    fputs("\n\n%%%%%%%%%%  KAREL PATH  %%%%%%%%%%\n", post);
    if(fscanf(path, "%d %d %d %d", &y1, &x1, &direction, &flag1) == 4)
    {   /* Read first line of the path file */
    /* Place Karel in his inital position */
    if(direction == 1)            /* Face Karel North */
      fprintf(post, "%d %d 90 head\n", x1 * MULT, y1 * MULT);
    else if(direction == 2)       /* Face Karel South */
      fprintf(post, "%d %d 270 head\n", x1 * MULT, y1 * MULT);
    else if(direction == 3)       /* Face Karel East */
      fprintf(post, "%d %d 0 head\n", x1 * MULT, y1 * MULT);
    else if(direction == 4)       /* Face Karel West */
      fprintf(post, "%d %d 180 head\n", x1 * MULT, y1 * MULT);
      while((fscanf(path, "%d %d %d %d", &y2, &x2, &flag2, &beepers2) == 4) && (ftell(path) < pos))
      {       /* Read rest of the path file */
          /* process karels path */
          if(x1 != x2 || y1 != y2)
      {
            if(x1 == x2 && y1 < y2)                 /* travling north */
                arrow((x1 * MULT) + 3, (y1 * MULT) + 3, (x2 * MULT) + 3, (y2 * MULT) - 3);
            else if(x1 == x2 && y1 > y2)    /* travling south */
            arrow((x1 * MULT) - 3, (y1 * MULT) - 3, (x2 * MULT) - 3, (y2 * MULT) + 3);
            else if(y1 == y2 && x1 < x2)    /* travling east */
                arrow((x1 * MULT) + 3, (y1 * MULT) - 3, (x2 * MULT) - 3, (y2 * MULT) - 3);
            else if(y1 == y2 && x1 > x2)    /* travling west */
                arrow((x1 * MULT) - 3, (y1 * MULT) + 3, (x2 * MULT) + 3, (y2 * MULT) + 3);
          }

          /* Pick/Put beepers down/up */
          if(flag2 == 1)
            fprintf(post, "%d %d (%d) pickbeeper\n", (x2 * MULT), (y2 * MULT), beepers2);
          if(flag2 == 2)
            fprintf(post, "%d %d (%d) putbeeper\n", (x2 * MULT), (y2 * MULT), beepers2);
          if(flag2 == 3)
            fprintf(post, "%d %d (%d) pick&put\n", (x2 * MULT), (y2 * MULT), beepers2);

          x1 = x2;
          y1 = y2;
      flag1 = flag2;
/*          beepers1 = beepers2;
  */    }
   }
      if(!flag1 || flag1)
   {       /* Handle if second to last is not a beeper */
            if(x1 == x2 && y1 < y2)                 /* travling north */
                arrow((x1 * MULT) + 3, (y1 * MULT) + 3, (x2 * MULT) + 3, (y2 * MULT) - 3);
            else if(x1 == x2 && y1 > y2)    /* travling south */
            arrow((x1 * MULT) - 3, (y1 * MULT) - 3, (x2 * MULT) - 3, (y2 * MULT) + 3);
            else if(y1 == y2 && x1 < x2)    /* travling east */
                arrow((x1 * MULT) + 3, (y1 * MULT) - 3, (x2 * MULT) - 3, (y2 * MULT) - 3);
            else if(y1 == y2 && x1 > x2)    /* travling west */
                arrow((x1 * MULT) - 3, (y1 * MULT) + 3, (x2 * MULT) + 3, (y2 * MULT) + 3);
   }


    /* Place Karel in his final position */
    if(flag2 == 1)              /* Face Karel North */
      fprintf(post, "%d %d 90 head\n", x2 * MULT, y2 * MULT);
    else if(flag2 == 2) /* Face Karel South */
      fprintf(post, "%d %d 270 head\n", x2 * MULT, y2 * MULT);
    else if(flag2 == 3) /* Face Karel East */
      fprintf(post, "%d %d 0 head\n", x2 * MULT, y2 * MULT);
    else if(flag2 == 4) /* Face Karel West */
      fprintf(post, "%d %d 180 head\n", x2 * MULT, y2 * MULT);


    /* Print turnoff/error status */
    fputs("normtxt setfont\n", post);
    if(beepers2 == 0)
    {                   /* Normal Execution */
      fprintf(post, "%d %d moveto\n(Normal Execution.     ", 25, error_pos);
    }
    else if(beepers2 == 1)
    {                   /* Error: Missing turnoff */
      fprintf(post, "%d %d moveto\n(Error shutoff: Missing turnoff Instruction.     ", 25, error_pos);
    }
    else if(beepers2 == 2)
    {                   /* Error: Hit Wall */
      fprintf(post, "%d %d moveto\n(Error shutoff: Hit Wall.     ", 25, error_pos);
    }
    else if(beepers2 == 3)
    {                   /* Error: Putting beeper down */
      fprintf(post, "%d %d moveto\n(Error shutoff: Putting beeper down.     ", 25, error_pos);
    }
    else if(beepers2 == 4)
    {                   /* Error: Picking beeper up */
      fprintf(post, "%d %d moveto\n(Error shutoff: Picking beeper up.     ", 25, error_pos);
    }
    else if(beepers2 == 5)
    {                   /* Error: Time-out */
      fprintf(post, "%d %d moveto\n(Error shutoff: Timed out.     ", 25, error_pos);
    }
    else if(beepers2 == 6)
    {                   /* Error: Message sent to off robot */
      fprintf(post, "%d %d moveto\n(Error shutoff: Message to off robot.     ", 25, error_pos);
    }
    error_pos -= 8;

    rewind(path);
}


void dofiles(char *filename, char **pth_file, char *wol_file, char *eps_file, char *basename)
{
    int x, y;
    char ext[45];

    x = strlen(filename) - 1;
    while(filename[x--] != '.' && x > -1);

    if(x > -1)
    {
      strncpy(basename, filename,x+1);
      basename[x + 1] = '\0';

      strcpy(ext, filename+x+2);

      if(!stricmp(ext, "wol"))
          strcpy(wol_file, filename);
      else if(!stricmp(ext, "pth")){
          while(*pth_file) pth_file++;
          *pth_file = malloc(strlen(filename)+1);
          strcpy(*pth_file, filename);
      }
      else if(!stricmp(ext, "eps"))
          strcpy(eps_file, filename);
      else
      {   /* Print Error Message if file type doesn't match those above */
          fprintf(stderr, "\aError: Invalid file type: %s.%s\n", basename, ext);
          exit(1);
      }
    }
    else
    {
      fprintf(stderr, "\aError: Invalid file type: %s\n", filename);
      exit(1);
    }
}

void file_err(void)
{
   exit(4);
}
